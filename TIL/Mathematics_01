#알고리즘 개념 정리 (2025-08-26)



### 1. 피사노 주기 (Pisano Period)

피보나치 수열을 특정 수 `K`로 나눈 나머지가 반복되는 패턴의 길이를 의미. 아주 큰 N번째 피보나치 수를 M으로 나눈 나머지를 구할 때 효과적.

**핵심 원리**
> `F(n) % M = F(n % 주기) % M`

**예시: K=3일 때**
- 피보나치 수열: 0, 1, 1, 2, 3, 5, 8, 13, ...
- 3으로 나눈 나머지: **`0, 1, 1, 2, 0, 2, 2, 1`**, 0, 1, ...
- `0, 1`이 다시 나올 때까지의 길이, 즉 주기는 **8**.

**알고 있으면 유용한 주기**
- `M = 10^k` (k > 2) 일 때, 주기 `P = 15 * 10^(k-1)`
- `M = 1,000,000` (10^6) -> 주기: `1,500,000`

---

### 2. 최장 연속 증가/감소 수열 (BOJ 2491)

수열에서 숫자가 연속적으로 커지거나(혹은 같거나) 작아지는(혹은 같은) 가장 긴 부분 수열의 길이를 찾는 문제.

**핵심 아이디어 (DP)**
- **시간 복잡도**: O(N) - 모든 원소를 한 번씩만 순회합니다.
- **공간 복잡도**: O(1) - 전체 수열을 저장할 필요 없이, 바로 이전 값과 현재까지의 길이만 기억하면 됩니다.

**최적화된 Java 코드**
```java
// O(1) 공간 복잡도 풀이
int prev = /* 첫 번째 숫자 */;
int incLen = 1; // 연속 증가 길이
int decLen = 1; // 연속 감소 길이
int maxLen = 1; // 전체 최장 길이

for (int i = 1; i < n; i++) {
    int current = /* 다음 숫자 */;

    // 증가 수열 길이 갱신
    if (current >= prev) incLen++;
    else incLen = 1;

    // 감소 수열 길이 갱신
    if (current <= prev) decLen++;
    else decLen = 1;

    // 전체 최장 길이 갱신
    maxLen = Math.max(maxLen, Math.max(incLen, decLen));
    prev = current;
}
System.out.println(maxLen);
```

---

### 3. 제곱수의 합 (BOJ 1699)

주어진 자연수 `N`을 제곱수들의 합으로 표현할 때, 필요한 항의 최소 개수를 찾는 문제.

**핵심 아이디어 (DP)**
- `dp[i]`: 숫자 `i`를 만드는 데 필요한 제곱수 항의 최소 개수
- **점화식**: `dp[i] = min(dp[i], dp[i - j*j] + 1)` (모든 `j*j <= i` 에 대하여)

**규칙을 찾는 법**
1. N=1부터 작은 수에 대해 손으로 직접 답을 구하며 표를 만든다.
2. `dp[i]`와 그 이전의 `dp` 값들(`dp[i-1]`, `dp[i-4]`, `dp[i-9]`, ...) 사이의 관계를 파악하여 점화식을 세운다.

**Java 코드**
```java
int[] dp = new int[n + 1];

for (int i = 1; i <= n; i++) {
    // 최악의 경우 (1^2을 i번 더하는 경우)로 초기화
    dp[i] = i; 
    
    // i보다 작은 모든 제곱수 j*j에 대해
    for (int j = 1; j * j <= i; j++) {
        // 기존 방법과, j*j를 사용하는 새로운 방법 중 더 나은 것을 선택
        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
    }
}
System.out.println(dp[n]);
```

---

### 4. 이항 계수 (Binomial Coefficient)

`n`개에서 `k`개를 순서 없이 뽑는 경우의 수(`nCk`)를 구하는 방법입니다. 문제의 조건에 따라 다른 접근법을 사용해야 합니다.

#### 방법 1: 파스칼의 삼각형 (DP)
- **점화식**: `nCk = (n-1)C(k-1) + (n-1)Ck`
- **언제 사용?**: `n`, `k`가 적당히 크고(e.g., 1000 내외), 나머지 연산이 필요할 때 가장 간단하고 효과적입니다.
- **장점**: 오버플로우 걱정이 없고, 코드가 직관적입니다.

**Java 코드 (BOJ 11051 유형)**
```java
int D = 10007; // 나누는 수
int[][] dp = new int[n + 1][n + 1];

for (int i = 0; i <= n; i++) {
    for (int j = 0; j <= i; j++) {
        if (j == 0 || j == i) {
            dp[i][j] = 1;
        } else {
            // 덧셈마다 나머지 연산을 수행하여 오버플로우 방지
            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % D;
        }
    }
}
System.out.println(dp[n][k]);
```

#### 방법 2: 페르마의 소정리와 모듈러 역원
- **공식**: `nCk % p = (n! * (k!(n-k)!)^(p-2)) % p` (단, `p`는 소수)
- **언제 사용?**: `n`이 매우 크고(`10^5` 이상), **소수** `p`로 나눈 나머지를 구해야 할 때 사용합니다.
- **핵심**: 나눗셈의 모듈러 연산은 직접 할 수 없으므로, 역원을 곱하는 방식으로 변환합니다.
